defmodule PacketFlow.ExecutionEngine do
  @moduledoc """
  Execution engine for PacketFlow capabilities and AI-generated plans.

  Handles execution of individual capabilities and orchestration of complex
  multi-step plans generated by the AI planner.
  """

  use GenServer
  require Logger

  # Public API

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @doc """
  Execute a single capability by ID.
  """
  def execute(capability_id, payload, context \\ %{}) do
    GenServer.call(__MODULE__, {:execute_capability, capability_id, payload, context}, 60_000)
  end

  @doc """
  Execute a complete AI-generated plan.
  """
  def execute_plan(plan, initial_payload, context \\ %{}) do
    GenServer.call(__MODULE__, {:execute_plan, plan, initial_payload, context}, 60_000)
  end

  @doc """
  Get execution status for a running plan.
  """
  def get_execution_status(execution_id) do
    GenServer.call(__MODULE__, {:get_status, execution_id})
  end

  # GenServer implementation

  @impl true
  def init(_opts) do
    # ETS table to track running executions
    :ets.new(:packet_flow_executions, [:named_table, :public, :set])

    Logger.info("PacketFlow.ExecutionEngine started")
    {:ok, %{}}
  end

  @impl true
  def handle_call({:execute_capability, capability_id, payload, context}, _from, state) do
    execution_id = generate_execution_id()

    result = execute_single_capability(capability_id, payload, context, execution_id)

    {:reply, result, state}
  end

  @impl true
  def handle_call({:execute_plan, plan, initial_payload, context}, _from, state) do
    execution_id = generate_execution_id()

    # Store execution metadata
    execution_meta = %{
      id: execution_id,
      plan: plan,
      status: :running,
      started_at: DateTime.utc_now(),
      steps_completed: 0,
      total_steps: get_total_steps(plan),
      context: context
    }

    :ets.insert(:packet_flow_executions, {execution_id, execution_meta})

    # Execute the plan
    result = execute_plan_steps(plan, initial_payload, context, execution_id)

    Logger.info("Plan execution completed with result: #{inspect(result)}")

    # Update final status
    final_meta = Map.merge(execution_meta, %{
      status: case result do
        {:ok, _} -> :completed
        {:error, _} -> :failed
        :ok -> :completed  # Handle bare :ok response
        _ -> :failed  # Handle any other unexpected response
      end,
      completed_at: DateTime.utc_now()
    })

    :ets.insert(:packet_flow_executions, {execution_id, final_meta})

    # Prepare the reply based on result type
    reply = case result do
      {:ok, data} when is_map(data) ->
        # Check if the plan has a response message that needs template substitution
        processed_data = case plan do
          %{"response_message" => response_msg} when is_binary(response_msg) ->
            substituted_response = substitute_templates(response_msg, data)
            Map.put(data, "response_message", substituted_response)
          %{:response_message => response_msg} when is_binary(response_msg) ->
            substituted_response = substitute_templates(response_msg, data)
            Map.put(data, "response_message", substituted_response)
          _ -> data
        end

        %{
          execution_id: execution_id,
          results: processed_data,
          status: :completed
        }
      {:ok, data} ->
        %{
          execution_id: execution_id,
          results: %{output: data},
          status: :completed
        }
      :ok ->
        %{
          execution_id: execution_id,
          results: %{},
          status: :completed
        }
      {:error, reason} ->
        %{
          execution_id: execution_id,
          error: reason,
          status: :failed
        }
      other ->
        %{
          execution_id: execution_id,
          results: %{output: other},
          status: :completed
        }
    end

    {:reply, reply, state}
  end

  @impl true
  def handle_call({:get_status, execution_id}, _from, state) do
    case :ets.lookup(:packet_flow_executions, execution_id) do
      [{^execution_id, meta}] -> {:reply, {:ok, meta}, state}
      [] -> {:reply, {:error, :execution_not_found}, state}
    end
  end

  # Private functions

  defp generate_execution_id do
    :crypto.strong_rand_bytes(16) |> Base.encode16(case: :lower)
  end

  defp execute_single_capability(capability_id, payload, context, execution_id) do
    # Add execution tracking to context
    enhanced_context = Map.merge(context, %{
      execution_id: execution_id,
      capability_id: capability_id,
      started_at: DateTime.utc_now()
    })

    # Convert string capability_id to atom if needed
    capability_atom = if is_binary(capability_id) do
      try do
        String.to_existing_atom(capability_id)
      rescue
        ArgumentError -> capability_id  # Keep as string if atom doesn't exist
      end
    else
      capability_id
    end

    case PacketFlow.CapabilityRegistry.get_capability(capability_atom) do
      {:ok, capability_meta} ->
        execute_capability_function(capability_meta, payload, enhanced_context)

      {:error, :not_found} ->
        Logger.error("Capability not found: #{capability_id}")
        {:error, {:capability_not_found, capability_id}}
    end
  end

  defp execute_capability_function(capability_meta, payload, context) do
    try do
            # Call the capability function on the module
      module = capability_meta.module
      capability_id = capability_meta.id

      Logger.info("Executing capability #{capability_id} on module #{module}")

      # Add telemetry
      :telemetry.execute(
        [:packet_flow, :capability, :start],
        %{},
        %{capability_id: capability_id, module: module}
      )

      start_time = System.monotonic_time(:microsecond)

      # Call the capability function
      result = apply(module, capability_id, [payload, context])

      end_time = System.monotonic_time(:microsecond)
      duration = end_time - start_time

      # Emit telemetry
      :telemetry.execute(
        [:packet_flow, :capability, :stop],
        %{duration: duration},
        %{capability_id: capability_id, module: module, result: result}
      )

      Logger.info("Capability #{capability_id} completed in #{duration}Î¼s")

      result
    rescue
      error ->
        Logger.error("Capability execution failed: #{inspect(error)}")

        :telemetry.execute(
          [:packet_flow, :capability, :error],
          %{},
          %{capability_id: capability_meta.id, error: error}
        )

        {:error, {:execution_failed, error}}
    end
  end

  defp execute_plan_steps(plan, initial_payload, context, execution_id) do
    # Handle both atom and string keys
    execution_plan = plan[:execution_plan] || plan["execution_plan"] || %{}
    steps = execution_plan[:steps] || execution_plan["steps"] || []
    plan_type = execution_plan[:type] || execution_plan["type"] || "sequential"

    case plan_type do
      "sequential" -> execute_sequential_steps(steps, initial_payload, context, execution_id)
      "parallel" -> execute_parallel_steps(steps, initial_payload, context, execution_id)
      "conditional" -> execute_conditional_steps(steps, initial_payload, context, execution_id)
      _ -> execute_sequential_steps(steps, initial_payload, context, execution_id)
    end
  end

  defp execute_sequential_steps(steps, initial_payload, context, execution_id) do
    Logger.info("Executing #{length(steps)} sequential steps for execution #{execution_id}")

    {final_result, final_payload} =
      Enum.reduce_while(steps, {:ok, initial_payload}, fn step, {_status, accumulated_payload} ->
        step_result = execute_plan_step(step, accumulated_payload, context, execution_id)

        case step_result do
          {:ok, step_output} ->
            # Store step output under step-specific key AND merge with accumulated payload
            step_key = step["id"]
            merged_payload = accumulated_payload
            |> Map.merge(step_output)  # Direct merge for backward compatibility
            |> Map.put(step_key, step_output)  # Step-specific data for templates

            update_execution_progress(execution_id)
            {:cont, {:ok, merged_payload}}

          {:error, reason} ->
            Logger.error("Step #{step["id"]} failed: #{inspect(reason)}")
            {:halt, {:error, {:step_failed, step["id"], reason}}}

          :error ->
            Logger.error("Step #{step["id"]} failed with unknown error")
            {:halt, {:error, {:step_failed, step["id"], :unknown_error}}}

          other ->
            Logger.error("Step #{step["id"]} returned unexpected result: #{inspect(other)}")
            {:halt, {:error, {:step_failed, step["id"], {:unexpected_result, other}}}}
        end
      end)

    case final_result do
      :ok ->
        # Create OUTPUTS structure for template substitution
        outputs = final_payload
        |> Enum.filter(fn {key, _value} -> is_binary(key) and String.starts_with?(key, "step_") end)
        |> Enum.into(%{})

        result_with_outputs = Map.put(final_payload, "OUTPUTS", outputs)
        {:ok, result_with_outputs}
      {:error, reason} -> {:error, reason}
      :error -> {:error, :unknown_error}
      other -> {:error, {:unexpected_result, other}}
    end
  end

  defp execute_parallel_steps(steps, initial_payload, context, execution_id) do
    Logger.info("Executing #{length(steps)} parallel steps for execution #{execution_id}")

    # Execute all steps in parallel
    tasks = Enum.map(steps, fn step ->
      Task.async(fn ->
        {step["id"], execute_plan_step(step, initial_payload, context, execution_id)}
      end)
    end)

    # Wait for all tasks to complete
    results = Task.await_many(tasks, 30_000)

    # Check if any failed
    failed_steps = Enum.filter(results, fn {_step_id, result} ->
      match?({:error, _}, result)
    end)

    if Enum.empty?(failed_steps) do
      # Combine all successful results
      combined_output = results
      |> Enum.reduce(%{}, fn {step_id, {:ok, output}}, acc ->
        Map.merge(acc, output)
      end)

      update_execution_progress(execution_id, length(steps))
      {:ok, combined_output}
    else
      Logger.error("Parallel execution failed. Failed steps: #{inspect(failed_steps)}")
      {:error, {:parallel_execution_failed, failed_steps}}
    end
  end

  defp execute_conditional_steps(steps, initial_payload, context, execution_id) do
    # For now, treat conditional as sequential
    # TODO: Implement proper conditional logic based on step conditions
    execute_sequential_steps(steps, initial_payload, context, execution_id)
  end

  defp execute_plan_step(step, payload, context, execution_id) do
    # Convert string capability_id to atom if needed (safely)
    capability_id = if is_binary(step["capability_id"]) do
      try do
        String.to_existing_atom(step["capability_id"])
      rescue
        ArgumentError -> step["capability_id"]  # Keep as string if atom doesn't exist
      end
    else
      step["capability_id"]
    end

    step_inputs = Map.get(step, "inputs", %{})

    # Perform template substitution on step inputs using accumulated payload data
    substituted_inputs = substitute_templates(step_inputs, payload)

    # Merge substituted step inputs with current payload
    step_payload = Map.merge(payload, substituted_inputs)

    # Add step context
    step_context = Map.merge(context, %{
      step_id: step["id"],
      step_description: step["description"],
      execution_id: execution_id
    })

    Logger.info("Executing step #{step["id"]}: #{step["description"]}")

    execute_single_capability(capability_id, step_payload, step_context, execution_id)
  end

  defp update_execution_progress(execution_id, steps_increment \\ 1) do
    case :ets.lookup(:packet_flow_executions, execution_id) do
      [{^execution_id, meta}] ->
        updated_meta = Map.update(meta, :steps_completed, steps_increment, &(&1 + steps_increment))
        :ets.insert(:packet_flow_executions, {execution_id, updated_meta})

      [] ->
        Logger.warn("Execution metadata not found for #{execution_id}")
    end
  end

  defp get_total_steps(plan) do
    # Handle both atom and string keys, with fallbacks
    execution_plan = plan[:execution_plan] || plan["execution_plan"] || %{}
    steps = execution_plan[:steps] || execution_plan["steps"] || []

    if is_list(steps) do
      length(steps)
    else
      0
    end
  end

  # Template substitution functions

  defp substitute_templates(data, substitution_data) when is_map(data) do
    Enum.reduce(data, %{}, fn {key, value}, acc ->
      Map.put(acc, key, substitute_templates(value, substitution_data))
    end)
  end

  defp substitute_templates(data, substitution_data) when is_list(data) do
    Enum.map(data, fn item -> substitute_templates(item, substitution_data) end)
  end

  defp substitute_templates(data, substitution_data) when is_binary(data) do
    # Replace template placeholders like {key} and $key with values from substitution_data
    data
    |> substitute_curly_braces(substitution_data)
    |> substitute_dollar_signs(substitution_data)
    |> substitute_angle_bracket_templates(substitution_data)
  end

  defp substitute_curly_braces(data, substitution_data) do
    Regex.replace(~r/\{([^}]+)\}/, data, fn _match, key ->
      case get_nested_value(substitution_data, key) do
        nil -> "{#{key}}"  # Keep placeholder if no substitution found
        value when is_binary(value) -> value
        value -> format_template_value(key, value)
      end
    end)
  end

  defp substitute_dollar_signs(data, substitution_data) do
    # First handle complex expressions with operators like "$OUTPUTS.step_1.main_topics + $OUTPUTS.step_1.key_points"
    data = Regex.replace(~r/\$([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_\[\]]+)*)\s*\+\s*\$([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_\[\]]+)*)/, data, fn _match, key1, key2 ->
      value1 = case get_nested_value(substitution_data, key1) do
        nil -> ""
        value when is_binary(value) -> value
        value when is_list(value) -> Enum.join(value, ", ")
        value -> format_template_value(key1, value)
      end

      value2 = case get_nested_value(substitution_data, key2) do
        nil -> ""
        value when is_binary(value) -> value
        value when is_list(value) -> Enum.join(value, ", ")
        value -> format_template_value(key2, value)
      end

      # Combine the values with proper formatting
      case {String.trim(value1), String.trim(value2)} do
        {"", ""} -> ""
        {v1, ""} -> v1
        {"", v2} -> v2
        {v1, v2} -> "#{v1}\n\n#{v2}"
      end
    end)

    # Then handle single template variables
    Regex.replace(~r/\$([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_\[\]]+)*)/, data, fn _match, key ->
      case get_nested_value(substitution_data, key) do
        nil -> "$#{key}"  # Keep placeholder if no substitution found
        value when is_binary(value) -> value
        value when is_list(value) -> Enum.join(value, ", ")
        value -> format_template_value(key, value)
      end
    end)
  end

  defp substitute_angle_bracket_templates(data, substitution_data) do
    # Handle templates like "<output from step_1>" or "<output from step_2>"
    Regex.replace(~r/<output from (step_\w+)>/i, data, fn _match, step_id ->
      case get_nested_value(substitution_data, step_id) do
        nil -> "<output from #{step_id}>"  # Keep placeholder if no substitution found
        step_data when is_map(step_data) ->
          # Try to get the most relevant field from the step data
          cond do
            Map.has_key?(step_data, "summary") -> Map.get(step_data, "summary")
            Map.has_key?(step_data, :summary) -> Map.get(step_data, :summary)
            Map.has_key?(step_data, "message") -> Map.get(step_data, "message")
            Map.has_key?(step_data, :message) -> Map.get(step_data, :message)
            Map.has_key?(step_data, "response") -> Map.get(step_data, "response")
            Map.has_key?(step_data, :response) -> Map.get(step_data, :response)
            Map.has_key?(step_data, "content") -> Map.get(step_data, "content")
            Map.has_key?(step_data, :content) -> Map.get(step_data, :content)
            true -> inspect(step_data)  # Fallback to inspect if no known fields
          end
        value when is_binary(value) -> value
        value -> inspect(value)
      end
    end)
  end

  defp substitute_templates(data, _substitution_data), do: data

  # Helper function to get nested values from maps using dot notation and array access
  defp get_nested_value(data, key) when is_map(data) do
    case String.split(key, ".") do
      [single_key] ->
        get_value_with_array_access(data, single_key)
      keys ->
        # Handle nested keys like "user.name" or "step_1.suggested_responses[0]"
        Enum.reduce(keys, data, fn k, acc ->
          if is_map(acc) or is_list(acc) do
            get_value_with_array_access(acc, k)
          else
            nil
          end
        end)
    end
  rescue
    ArgumentError -> Map.get(data, key)  # Fallback if atom doesn't exist
  end

  defp get_value_with_array_access(data, key) when is_map(data) do
    case Regex.run(~r/^([^[]+)\[(\d+)\]$/, key) do
      [_, base_key, index_str] ->
        # Handle array access like "suggested_responses[0]"
        index = String.to_integer(index_str)
        base_value = Map.get(data, base_key) ||
                    (try do
                      Map.get(data, String.to_existing_atom(base_key))
                    rescue
                      ArgumentError -> nil
                    end)

        if is_list(base_value) and index >= 0 and index < length(base_value) do
          Enum.at(base_value, index)
        else
          nil
        end

      nil ->
        # No array access, just regular key lookup
        Map.get(data, key) ||
        (try do
          Map.get(data, String.to_existing_atom(key))
        rescue
          ArgumentError -> nil
        end)
    end
  end

  defp get_value_with_array_access(data, key) when is_list(data) do
    case Regex.run(~r/^\[(\d+)\]$/, key) do
      [_, index_str] ->
        index = String.to_integer(index_str)
        if index >= 0 and index < length(data) do
          Enum.at(data, index)
        else
          nil
        end
      nil ->
        nil
    end
  end

  defp get_value_with_array_access(_data, _key), do: nil

  defp get_nested_value(_data, _key), do: nil

  # Format template values for better display
  defp format_template_value("activity_summary", %{} = summary) do
    active_users = Map.get(summary, :active_users) || Map.get(summary, "active_users")
    total_messages = Map.get(summary, :total_messages) || Map.get(summary, "total_messages")
    message_frequency = Map.get(summary, :message_frequency) || Map.get(summary, "message_frequency")

    """
    ð **Activity Summary**
    â¢ Active Users: #{active_users}
    â¢ Total Messages: #{total_messages}
    â¢ Message Frequency: #{Float.round(message_frequency || 0, 2)} messages/minute
    """
  end

  defp format_template_value("participant_insights", %{} = insights) do
    engagement_level = Map.get(insights, :engagement_level) || Map.get(insights, "engagement_level")
    most_active_user = Map.get(insights, :most_active_user) || Map.get(insights, "most_active_user")

    """
    ð¥ **Participant Insights**
    â¢ Engagement Level: #{engagement_level}
    â¢ Most Active User: #{most_active_user}
    """
  end

  defp format_template_value("key_topics", topics) when is_list(topics) do
    case topics do
      [] -> "No key topics identified"
      topics -> "ð·ï¸ " <> Enum.join(topics, ", ")
    end
  end

  defp format_template_value("trending_topics", topics) when is_list(topics) do
    format_template_value("key_topics", topics)
  end

  defp format_template_value(_key, value) do
    inspect(value)  # Fallback for other values
  end
end
